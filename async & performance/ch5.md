# Вы не знаете JS: Асинхронность & Производительность
# Глава 5: Производительность программы

До этого момента в книге мы говорили о том, как работать с асинхронностью более эффективно, но мы все еще не обсудили, почему асинхронность так важна. Наиболее очевидная причина это **производительность**.

Например, нужно сделать два независимых Ajax запроса, а затем дождаться момента завершения обоих, прежде чем перейти к следующей задаче. Можно сделать это двумя способами: последовательно и параллельно.

Вы могли бы сделать первый запрос, дождаться его завершения и только потом запустить второй. Или, как мы уже делали это с обещаниями и генераторами, вы могли бы запустить их "параллельно" и дождаться завершения обоих запросов.

Очевидно, что второй вариант в большинстве случаев будет более производительным и даст лучший пользовательский опыт.

Более того, асинхронность может улучшить только восприятие производительности, даже если программа исполняется за тот же период времени. Пользовательское восприятие так же (а то и более) важно, как и измеряемая производительность.

Теперь мы можем перейти от частных примеров асинхронности к более общей картине -- производительности на уровне приложения.

**Примечание:** Возможно вас интересуют вопросы микропроизводительности, такие как "Что исполняется быстрее: `a++` или `++a`?". Мы рассмотрим такие вопросы в следующей главе.

## Web Workers (Веб Воркеры)

Иногда вам необходимо выполнить вычислительно сложные задачи, но при этом вы не хотите "захламлять" ими основной поток (что может привести к замедлению работы браузера / пользовательского интерфейса). В таким моменты очень хочется, чтобы JavaScript имел многопоточность.

В главе 1 мы обсудили, что JavaScript исполняется в одном потоке. Это все еще так. Но этот поток все еще не единственная возможность организации вашей программы.

Представьте, что можно было бы разбить вашу программу на 2 части, одна из которых исполнялась бы в основном UI потоке, а другая — в отдельном.

Какие особенности принесла бы такая архитектура?

Во-первых, хотелось бы знать, исполняются ли эти потоки параллельно (на системах с несколькими процессорами), поскольку это позволило бы вычислительному процессу **не** блокировать основной поток программы, иначе такая "виртуальная многопоточность" не имела бы преимуществ относительно той, который мы и так имеем.

Так же хотелось бы знать, имеют ли обе части программы доступ к одним и тем же ресурсам. Если это действительно так, то мы сталкиваемся с теми же вопросами, с которыми сталкиваются языки с поддержкой многопоточности (Java, C++, и так далее), и будем вынуждены поддерживать такие механизмы как совместные и превентивные блокировки (мьютексы и так далее). Решение таких проблем - большая и серьезная работа.

Так же хотелось бы знать, смогут ли обе части программы взаимодействовать между собой, если у них нет доступа к единым ресурсам.

Все эти вопросы мы обсудим при рассмотрении веб-воркеров. Это особенность браузера (окружения) и практически не связана с языком JavaScript. На **текущий** момент в JavaScript нет возможности исполнения потоков.

Но окружение (тот же браузер) может легко предоставить несколько экземпляров движка, исполняющего JavaScript, каждый из которых будет исполняться в отдельном потоке и позволит исполнять разные программы в каждом из них. Каждый из этих потоков называется "(Веб-)Воркер". Такой тип параллелизма называется "задачным параллелизмом", так как он имеет уклон на разбиение вашей программы на отдельные части для исполнения их параллельно.

Для создания нового воркера из основного скрипта (или скрипта другого воркера) выполните:

```js
var w1 = new Worker( "http://some.url.1/mycoolworker.js" );
```

Ссылка должна указывать на JS-файл (не страницу HTML!), который необходимо загрузить в воркер. Браузер запустит отдельный поток и позволит этому файлу в нем исполняться.

**Примечание:** Такой тип воркера называется выделенным. Можно также создать инлайн-воркер с использованием Blob URL: по сути это файл, сохраненный в строке. Однако в этой главе мы не будет обсуждать такой вариант.

Воркеры не могут взаимодействовать с ресурсами друг друга и основной программы — это привело бы ко всем кошмарам из поточного программирования. Вместо этого они имеют событийный механизм общения.

Воркер `w1` - объект, имеющий методы для прослушивания и отправки событий.

Таким образом можно подписаться на событие `"message"`:

```js
w1.addEventListener( "message", function(evt){
	// evt.data
} );
```

Таким образом можно отправить событие `"message"` воркеру:

```js
w1.postMessage( "something cool to say" );
```

Внутри воркера общение симметрично:

```js
// "mycoolworker.js"

addEventListener( "message", function(evt){
	// evt.data
} );

postMessage( "a really cool reply" );
```

Заметьте, что выделенный воркер соотносится один-к-одному с программой, которая его создала. В событии `"message"` нет никаких признаков, откуда оно пришло, поскольку оно могло придти только из воркера или основной страницы.

Обычно основная страница создаёт воркеры, однако воркер можно создать свои воркеры — сабворкеры — если это необходимо. Иногда это бывает полезно. Однако, на момент написания этой статьи, Chrome все еще не поддерживает сабворкеры (зато их поддерживает Firefox).

Чтобы уничтожить воркер из программы, которая его создала, вызовите метод `terminate()` у объекта воркера (`w1` в предыдущих примерах). Такое уничтожение не оставляет воркеру возможности закончить свою работу или освободить ресурсы. В каком-то смысле это похоже на закрытие вкладки или страницы.

Если у вас есть несколько страниц (или несколько вкладок одной и той же страницы) которые создают воркер из одного и того же файла, то они создадут разные воркеры. Позже мы обсудим, как можно "расшарить" воркер.

**Примечание:** На данный момент все выглядит так, будто JS-программа легко может создать DDOS атаку путем создания большого количества воркеров, каждый в своём потоке, однако операционная система сама решает, сколько потоков ей создавать. Нет возможности предсказать или гарантировать количество потоков, к которым у вас будет доступ. Многие разработчики считают, что доступных потоков будет не менее доступных ядер ЦПУ. Я считаю, что самым безопасным предположением будет считать, что есть как минимум один другой поток.

### Окружение воркера

Внутри воркера у вас нет доступа к любым ресурсам основной программы. Это означает, что вы не можете читать её глобальные переменные или обратиться к DOM. Это отдельный поток приложения.

Вы можете. однако, выполнить сетевой запрос (Ajax, WebSockets) и устанавливать таймеры. Также воркер имеет доступ к своей копии важный глобальных переменных, такие как `navigator`, `location`, `JSON`, `applicationCache`.

Также можно импортировать другие JS скрипты с помощью функции `importScripts(...)`:

```js
// inside the Worker
importScripts( "foo.js", "bar.js" );
```

Эти скрипты загружаются синхронно: это означает что вызов `importScripts(...)` заблокирует выполнение воркера до тех пор, пока скрипты не загрузятся.

**Примечание:** В данный момент обсуждается вопрос предоставления доступа воркеров к `<canvas>` API, что позволит воркерам выполнять графические задачи вне основного потока, что может быть полезным для приложений, требующих большую производительность (WebGL). Несмотря на то, что такого доступа нет на текущий момент, скорее всего такая доработка произойдет в ближайшем будущем.

Когда стоит использовать Веб-воркеры?

* Сложные математические вычисления
* Сортировка больших объёмов данных
* Операции над данными (компрессия, аудио-анализ, пиксельная манипуляции над изображениями, т.д.)
* Высоконагруженные сетевые коммуникации

### Передача данных

Вы можете заметить, что большинство случаев когда стоит использовать Веб-воркеры требуют передачи большого объёма данных через события, иногда в обе стороны.

Раньше единственным способом передачи данных была сериализация данных в строку. Основными недостатками такого способа являются скорость и то, что данные копируются, что увеличивает нагрузка на память и сборщик мусора.

Однако сейчас нам доступны и другие способы.

Если вы передаете объект, так называемый "Алгоритм структурного клонирования" (https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/The_structured_clone_algorithm) используется для дублирования объекта. Этот алгоритм достаточно сложен и даже может обрабатывать объект с циклическими ссылками. Таким образом исчезает необходимость постоянно сериализовать/десериализовать данные, но мы по-прежнему используем двойной объём памяти. Данный подход поддерживается IE10 и дальше, а также всеми мажорными версиями остальных браузеров.

Способ еще лучше, особенно для больших объёмов данных, заключается в использовании "передаваемых объектов" (http://updates.html5rocks.com/2011/12/Transferable-Objects-Lightning-Fast). В таком случае передаются "права" на данные. Как только вы передали объект воркеру, он становится недоступным или пустым в оригинальном скрипте — что позволяется избежать проблем поточного программирования. Конечно, передача таких прав может выполнятся в обе стороны.

Любая структура данных, которая реализует интерфейс Transferable будет автоматически передана таким образом (https://developer.mozilla.org/en-US/docs/Web/API/Transferable) (поддерживается в Firefox & Chrome).

Например, типизированные массивы (например, `Uint8Array`) являются передаваемыми. Таким образом можно послать передаваемый объект с помощью метода `postMessage(...)`:

```js
// `foo` является `Uint8Array`

postMessage( foo.buffer, [ foo.buffer ] );
```

Первый параметр — буфер сырых данных, второй — список данных для передачи.
Браузеры, не поддерживающие передаваемые объекты, будут передавать их с помощью алгоритм структурного клонирования. Таким образом, наш код потеряет в производительности, но продолжит работать.

### Разделяемые воркеры (Shared Workers)

Если ваш сайт или приложение позволяют загружать несколько вкладок одной страницы вам может пригодится возможность уменьшить количество используемых ресурсов за счет предотвращения дублирования выделенных воркеров. Наиболее часто нас интересует сетевое соединение, так как браузеры ограничивают количество одновременных подключений к одному хосту. Также при ограничении количества запросов с клиента уменьшается нагрузка на сервер.

В таком случае нам пригодится возможность создания единого, центрального воркера для всех страниц.
Такой воркер называется `SharedWorker` (разделяемый воркер), его можно создать таким образом (поддержка ограничена Firefox и Chrome):

```js
var w1 = new SharedWorker( "http://some.url.1/mycoolworker.js" );
```

Так как разделяемый воркер может быть подключен к нескольким страницам сайта ему необходимо знать, от какой из страниц пришло сообщение. Такая идентификация осуществляется с помощью портов. Вызывающая программа должна использовать этот объект при коммуникации:

```js
w1.port.addEventListener( "message", handleMessages );

// ..

w1.port.postMessage( "something cool" );
```

Соединение по порту должно быть инициализировано:

```js
w1.port.start();
```

Внутри разделяемого воркера появляется новый тип событий: `"connect"`. Это событие содержит объект порта для конкретного соединения. Обычно для разделения нескольких соединений используются замыкания с портом:

```js
// inside the shared Worker
addEventListener( "connect", function(evt){
	// the assigned port for this connection
	var port = evt.ports[0];

	port.addEventListener( "message", function(evt){
		// ..

		port.postMessage( .. );

		// ..
	} );

	// initialize the port connection
	port.start();
} );
```

Помимо этого разделяемые и выделенные воркеры имеют одинаковые возможности.

**Примечание:** Разделяемые воркеры «переживают» удаление одного из соединений, в то время как выделенные воркеры удаляются в тот же момент, что и соединение из вызывающей программы.

### Полифиллы веб-воркеров

Веб-воркеры выглядят очень привлекательно с точки зрения производительности и запуска JS-программ параллельно. Однако скорее всего вам необходимо поддерживать старые браузеры, у которых нет поддержки веб-воркеров. Поскольку воркеры это API, а не синтаксис, их можно заполифиллить (на какую-то часть).

Если браузер не поддерживает воркеры у нас нет простого способа сымитировать мультипоточность с точки зрения производительности. Часто считается, что фреймы могут предоставить такое окружение, но все современные браузеры запускают их в том же потоке, что и основную страницу.

Как мы разобрали в первой главе, асинхронность JS (не параллелизм) основана на очереди событий, то есть вы можете заставить фейковые воркеры исполняться асинхронно (`setTimeout(...)`, и так далее). Потом остаётся только предоставить полифилл к API воркера. Несколько вариантов предоставлены здесь (https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers), но, честно говоря, ни один из вариантов не выглядит достаточно хорошо.

Я написал набросок полифилла воркера здесь (https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills#web-workers). Он достаточно базовый, но предоставляет простую поддержку воркеров (коммуникация между воркерами и обработка ошибок `onerror`). Вы также можете расширить его нужными возможностями, например, методом `terminate()` или фейковыми разделяемыми воркерами.

**Примечание** Невозможно заполифиллить синхронное блокирование, поэтому заблокирован метод `importScripts(...)`. Другой способ мог бы заключатся в разборе и трансформации кода воркера для перезаписи асинхронной формы `importScripts(..)`, например, в интерфейс, основанный на промисах.

## ОКМД (SIMD)

Одиночный поток данных (одна команда, множество данных - ОКМД или SIMD) — форма параллелизма на уровне данных, в отличии от «параллелизма задач», в таком случае акцент делается не на частях программной логики, а на том, что множество частей данных обрабатываются параллельно.

В случае ОКМД не потоки обеспечивают параллелизм. Современные процессоры обеспечивают ОКМД при работе с векторами чисел - например, специализированные массивы - а так же инструкции, которые могут оперировать со всеми числами. Такие низкоуровневые операции предоставляют параллелизм на уровне инструкций.

Популяризацией ОКМД в контексте JavaScript в основном занимается Intel (https://01.org/node/1495), например, Mohammad Haghighat, при содействии команд Firefox и Chrome. На данный момент пишутся первые варианты стандартов, у которых есть хорошие шансы попасть в будущую спецификацию JavaScript, например, ES7.

ОКМД в JavaScript предполагает к получению доступа к типизированным векторам и их API в JS коде, которые при работе на системах, поддерживающих ОКМД, будут обеспечивать вычисление напрямую через процессор.

Польза, которую мог бы принести такой подход в приложениях с большим количеством данных, достаточно очевидна!

В ранних черновиках можно увидеть такие примеры использования API для работы с ОКМД:

```js
var v1 = SIMD.float32x4( 3.14159, 21.0, 32.3, 55.55 );
var v2 = SIMD.float32x4( 2.1, 3.2, 4.3, 5.4 );

var v3 = SIMD.int32x4( 10, 101, 1001, 10001 );
var v4 = SIMD.int32x4( 10, 20, 30, 40 );

SIMD.float32x4.mul( v1, v2 );	// [ 6.597339, 67.2, 138.89, 299.97 ]
SIMD.int32x4.add( v3, v4 );		// [ 20, 121, 1031, 10041 ]
```

В примере показаны 2 типа векторов, 32-битный для чисел с плавающей точкой и 32-битный для целых чисел. Вы можете заметить, что размеры этих векторов пропорциональны 4 32-битным элементам, так как это совпадает с размерами векторов ОКМД (128 бит) в большинстве современных ЦПУ. Возможно в дальнейшем мы увидим `x8` (или еще больше!) версии этих API.

Помимо `mul()` и `add()`, многие другие операции, скорее всего, так же будут добавлены, такие как `sub()`, `div()`, `abs()`, `neg()`, `sqrt()`, `reciprocal()`, `reciprocalSqrt()` (арифметические), `shuffle()` (перестановка элементов вектора), `and()`, `or()`, `xor()`, `not()` (логические), `equal()`, `greaterThan()`, `lessThan()` (сравнение), `shiftLeft()`, `shiftRightLogical()`, `shiftRightArithmetic()` (сдвиги), `fromFloat32x4()`, и `fromInt32x4()` (преобразование).

**Примечание:** Существует "полифилл" для работы с ОКМД (https://github.com/johnmccutchan/ecmascript_simd), который показывает намного больше возможностей этой технологии.

## asm.js

"asm.js" (http://asmjs.org/) это название для наиболее оптимизируемого подмножества языка JavaScript. С помощью избегания некоторых механизмов и паттернов (сборка мусора,  приведение типов, и так далее), код asm.js может быть максимально оптимизирован JS движком.

В отличии от других механизмов оптимизации для asm.js не нужно ничего принимать в спецификацию JavaScript. Несмотря на то, что спецификация asm.js существует (http://asmjs.org/spec/latest/), она в основном служит местом для обсуждения, нежели набором требований к движкам JS.

В данный момент не выдвигается нового синтаксиса. asm.js предлагает способы определения JS-кода, подходящего по правилам asm.js и позволяет движкам использовать их оптимизационные механизмы.

Существует разногласие между вендорами браузеров по поводу того, как asm.js должен активироваться в программе. Ранние версии asm.js требовали выражения `"use asm";`. Другие предполагали, что asm.js должен быть наборов эвристик, подсказывающих движкам возможность оптимизации без явного вмешательства, что позволило бы существующим программам получить оптимизации asm.js.

### Как оптимизировать с asm.js

Первое, что стоит понять о оптимизациях asm.js это то, что они используют типы и приведение типов. Если JS движку необходимо следить за несколькими типами значений внутри переменной, для того, чтобы обеспечить корректное приведение типов при операциях, то это уменьшает производительность программы.

**Примечание:** Мы собираемся разобрать код asm.js для примера, но имейте в виду, что такой код обычно является результатом компиляции из различных инструментов, таких как Emscripten (https://github.com/kripken/emscripten/wiki). Конечно, возможно написать asm.js код от руки, но обычно это плохая идея: на это тратится очень много времени и очень легко ошибиться.

Если несколько «приёмов», которые вы можете использовать для того, чтобы подсказать JS движку о типе переменной/операции, что позволит ему пропустить этап приведения типов:

```js
var a = 42;

// ..

var b = a;
```

В этой программе `b = a` оставляет открытым вопрос о совпадении типов в переменных. Однако этот код можно переписать так:

```js
var a = 42;

// ..

var b = a | 0;
```

В этом примере мы использовали `|` ("бинарное или") с значение `0`, что никак не влияет на значение, только подсказывает, что оно является 32-битным целым. Этот код работает в обычных JS-движках, но в движках, знающих об asm.js, он может «сообщить» о том, что `b` следует обрабатывать как 32-битное целое, что позволит пропустить приведения типов.

Сложение 2-х переменных может быть более производительно при целочисленном сложении (вместо сложения чисел с плавающей точкой):

```js
(a + b) | 0
```

Опять же, движки JS могут заметить подсказку, что операция сложения будет в любом случае 32-битным целым.

### asm.js модули

One of the biggest detractors to performance in JS is around memory allocation, garbage collection, and scope access. asm.js suggests one of the ways around these issues is to declare a more formalized asm.js "module" -- do not confuse these with ES6 modules; see the *ES6 & Beyond* title of this series.

For an asm.js module, you need to explicitly pass in a tightly conformed namespace -- this is referred to in the spec as `stdlib`, as it should represent standard libraries needed -- to import necessary symbols, rather than just using globals via lexical scope. In the base case, the `window` object is an acceptable `stdlib` object for asm.js module purposes, but you could and perhaps should construct an even more restricted one.

You also must declare a "heap" -- which is just a fancy term for a reserved spot in memory where variables can already be used without asking for more memory or releasing previously used memory -- and pass that in, so that the asm.js module won't need to do anything that would cause memory churn; it can just use the pre-reserved space.

A "heap" is likely a typed `ArrayBuffer`, such as:

```js
var heap = new ArrayBuffer( 0x10000 );	// 64k heap
```

Using that pre-reserved 64k of binary space, an asm.js module can store and retrieve values in that buffer without any memory allocation or garbage collection penalties. For example, the `heap` buffer could be used inside the module to back an array of 64-bit float values like this:

```js
var arr = new Float64Array( heap );
```

OK, so let's make a quick, silly example of an asm.js-styled module to illustrate how these pieces fit together. We'll define a `foo(..)` that takes a start (`x`) and end (`y`) integer for a range, and calculates all the inner adjacent multiplications of the values in the range, and then finally averages those values together:

```js
function fooASM(stdlib,foreign,heap) {
	"use asm";

	var arr = new stdlib.Int32Array( heap );

	function foo(x,y) {
		x = x | 0;
		y = y | 0;

		var i = 0;
		var p = 0;
		var sum = 0;
		var count = ((y|0) - (x|0)) | 0;

		// calculate all the inner adjacent multiplications
		for (i = x | 0;
			(i | 0) < (y | 0);
			p = (p + 8) | 0, i = (i + 1) | 0
		) {
			// store result
			arr[ p >> 3 ] = (i * (i + 1)) | 0;
		}

		// calculate average of all intermediate values
		for (i = 0, p = 0;
			(i | 0) < (count | 0);
			p = (p + 8) | 0, i = (i + 1) | 0
		) {
			sum = (sum + arr[ p >> 3 ]) | 0;
		}

		return +(sum / count);
	}

	return {
		foo: foo
	};
}

var heap = new ArrayBuffer( 0x1000 );
var foo = fooASM( window, null, heap ).foo;

foo( 10, 20 );		// 233
```

**Note:** This asm.js example is hand authored for illustration purposes, so it doesn't represent the same code that would be produced from a compilation tool targeting asm.js. But it does show the typical nature of asm.js code, especially the type hinting and use of the `heap` buffer for temporary variable storage.

The first call to `fooASM(..)` is what sets up our asm.js module with its `heap` allocation. The result is a `foo(..)` function we can call as many times as necessary. Those `foo(..)` calls should be specially optimized by an asm.js-aware JS engine. Importantly, the preceding code is completely standard JS and would run just fine (without special optimization) in a non-asm.js engine.

Obviously, the nature of restrictions that make asm.js code so optimizable reduces the possible uses for such code significantly. asm.js won't necessarily be a general optimization set for any given JS program. Instead, it's intended to provide an optimized way of handling specialized tasks such as intensive math operations (e.g., those used in graphics processing for games).

## Review

The first four chapters of this book are based on the premise that async coding patterns give you the ability to write more performant code, which is generally a very important improvement. But async behavior only gets you so far, because it's still fundamentally bound to a single event loop thread.

So in this chapter we've covered several program-level mechanisms for improving performance even further.

Web Workers let you run a JS file (aka program) in a separate thread using async events to message between the threads. They're wonderful for offloading long-running or resource-intensive tasks to a different thread, leaving the main UI thread more responsive.

SIMD proposes to map CPU-level parallel math operations to JavaScript APIs for high-performance data-parallel operations, like number processing on large data sets.

Finally, asm.js describes a small subset of JavaScript that avoids the hard-to-optimize parts of JS (like garbage collection and coercion) and lets the JS engine recognize and run such code through aggressive optimizations. asm.js could be hand authored, but that's extremely tedious and error prone, akin to hand authoring assembly language (hence the name). Instead, the main intent is that asm.js would be a good target for cross-compilation from other highly optimized program languages -- for example, Emscripten (https://github.com/kripken/emscripten/wiki) transpiling C/C++ to JavaScript.

While not covered explicitly in this chapter, there are even more radical ideas under very early discussion for JavaScript, including approximations of direct threaded functionality (not just hidden behind data structure APIs). Whether that happens explicitly, or we just see more parallelism creep into JS behind the scenes, the future of more optimized program-level performance in JS looks really *promising*.
